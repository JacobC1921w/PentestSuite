/* getServiceByPort() takes in an integer, i.e 80, and spits out what kind of service is usally associated with that port, i.e http.
 * Obviously port 80 isn't confined to http, it could be an SSH port, but it gives a main idea.
*/
const char* getServiceByPort(int portNumber) {
  struct servent *service = getservbyport(htons(portNumber), NULL);
  if (service == NULL) {
    return "unknown";
  } else {
    return service->s_name;
  }
}

/* match() takes in a regex string and a string to match. It will return 0 if the string matches, 1 if it doesnt, and 2 if it
 * doesn't compile correctly, i.e incorrect syntax
*/
int match(const char *restrict regexString, const char *inputText) {
  regex_t regex;
  int returnInt = regcomp(&regex, regexString, REG_EXTENDED);

  // Regex doesnt compile properly (i.e. incorrect syntax)
  if(returnInt) {
    regfree(&regex);
    return 2;
  }

  returnInt = regexec(&regex, inputText, 0, NULL, 0);
  regfree(&regex);

  // String matches regex
  if(!returnInt) {
    return 0;

  // String doesn't match regex
  } else {
    return 1;
  }
}

// validateIP() Takes an IP address, and checks if its valid. It does this by splitting the IP address by a '.' character. It then check if the segment is above 1 and below 255, as well as counting how many segments there are
bool validateIP(char *IPAddress) {
  char *splitToken = strtok(IPAddress, ".");
  int currentIPSegment;
  int IPIterations = 0;
  while (splitToken != NULL) {
    currentIPSegment = atoi(splitToken);

    if (currentIPSegment < 0 || currentIPSegment > 255) {
      return false;
    }
    IPIterations++;
    splitToken = strtok(NULL, ".");
  }
  // Make sure there is 4 segments
  if (IPIterations == 4) {
    return true;
  } else {
    return false;
  }
}

// isUp() Takes an IP address and a port as input, and checks if that port is open. Running this through a loop creates a lot of network traffic, so not recommended in public at all. Returning 0 menas the port is open, 1 means the port is closed, 2 means the socket failed to create, and 3 means the given IP is invalid
int isUp(char *IPAddress, int port) {
  // Create socket file descriptor, return 2 if it fails to create socket
  int socketFD = socket(AF_INET, SOCK_STREAM, 0);
  if (socketFD < 0) {
    return 2;
  }

  // Convert IP address to decimal form usable by connect(), return 3 if invalid IP addres
  struct sockaddr_in serverAddress;
  serverAddress.sin_family = AF_INET;
  serverAddress.sin_port = htons(port);

  if (inet_pton(AF_INET, IPAddress, &serverAddress.sin_addr) <= 0) {
    return 3;
  }

  // Create client socket file descriptor, return 1 if there is no connection (port isn't open)
  int clientFD = connect(socketFD, (struct sockaddr*)&serverAddress, sizeof(serverAddress));
  if (clientFD < 0) {
    return 1;
  }

  // All is well, port is open, return 0;
  close(clientFD);
  return 0;
}

void printHelp(char *programName) {
  printf("Usage: %s [OPTION...] IP1 IP2 .. IPN...\n", programName);
  printf("\n");
  printf("  -h, --help\t\tgives this help list\n");
  printf("  -v, --verbose\t\tuse verbose outputting\n");
  printf("  -p, --ports=MODE\tuse a specific port selection\n");
  printf("\n");
  printf(" Modes:\n");
  printf("  all\t\t\tall ports between 1 & 65535 will be used (slower)\n");
  printf("  top1000\t\ttop 1000 most used ports will be used (faster)\n");
  printf("  <min-max>\t\tports will be scanned between <min> and <max>, i.e\n");
  printf("\t\t\t  $ %s -p 3-10 192.168.0.4 192.168.0.5\n", programName);
  printf("\t\t\t  all ports between 3 and 10 will be scanned, on both selected host(s)\n");
  printf("  p1,p2,...pN\t\tselected ports will be scanned, i.e\n");
  printf("\t\t\t  $ %s -p 22,80,443,21 10.0.0.1 10.0.0.5\n", programName);
  printf("\t\t\t  only ports 22, 80, 443, and 21 will be scanned on selected host(s)\n");
  printf("\n");
  printf("All options are optional, and the top 1000 ports will be selected by default\n");
  printf("\n");
  printf("Report bugs to this pograms github issues page\n");
}
