// gcc portscan.c -Wall -o portscan.c.out

/*
 * This program will:
 * - Parse command line args (--help/-h, --timeout/-t, --ports/-p = all, range, top1000)
 * - Take one or multiple IP Addresses from STDIn
 * - Parity check getServiceByPort
 * - Check if host(s) are online
 * - scan selected ports, return values
*/

/* TODO:
 * - Maybe make a way to change mac address and IP for stealth scanning?
 * - put command line parsing into another file
*/

#include <stdio.h>
#include <netdb.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <regex.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <sys/time.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <errno.h>
#include <fcntl.h>
#include "main.h"
#include "top1000ports.c"

int main(int argc, char *argv[]){

  // Various variables
  bool skipThisIteration = false;
  int portBounds[2];
  int tempIncrementor = 0;
  int timeout = 300;
  char *splitToken;
  int argvHostIndex[255];
  int argvHostIndexIterator = 0;
  char *currentArgVIP = (char *) malloc(sizeof(char) * 15);
  char *currentArgVPortRange = (char *) malloc(sizeof(char) * 11);
  char *currentArgVPorts = (char *) malloc(sizeof(char) * 1024);
  extern int ports[];

  // Print help if there is no arguments supplied
  if (argc == 1) {
    printHelp(argv[0]);
    exit(1);
  }

  // Parse command line arguments
  for(int i = 1; i < argc; i++) {
    // Check if we should skip this iteration. Used if an argument has data following it
    if (skipThisIteration) {
      skipThisIteration = false;
    } else {

      // Help menu
      if (strcmp(argv[i], "-h") == 0 || strcmp(argv[i], "--help") == 0) {
        printHelp(argv[0]);
        return 0;

      // Parse timeout
      } else if (strcmp(argv[i], "-t") == 0 || strcmp(argv[i], "--timeout") == 0) {
        timeout = atoi(argv[i + 1]);
        skipThisIteration = true;

      // What kind of ports
      } else if (strcmp(argv[i], "-p") == 0 || strcmp(argv[i], "--ports") == 0) {
        if (strcmp(argv[i + 1], "all") == 0) {
          for (int i = 1; i <= 65535; i++) {
            ports[i - 1] = i;
          }
          skipThisIteration = true;
        
        // Some regex to check corect format of argument
        } else if (match("^()([1-9]|[1-5]?[0-9]{2,4}|6[1-4][0-9]{3}|65[1-4][0-9]{2}|655[1-2][0-9]|6553[1-5])-()([1-9]|[1-5]?[0-9]{2,4}|6[1-4][0-9]{3}|65[1-4][0-9]{2}|655[1-2][0-9]|6553[1-5])$", argv[i + 1]) == 0) {
          // Clear current ports list
          for (int i = 0; i <= 65535; i++) {
            ports[i] = 0;
          }

          // Sanitise input, this gets ugly, but basically we're splitting the input string into two different array entries
          strcpy(currentArgVPortRange, argv[i + 1]);
          splitToken = strtok(currentArgVPortRange, "-");
          tempIncrementor = 0;
          while (splitToken != NULL) {
            portBounds[tempIncrementor] = atoi(splitToken);
            tempIncrementor++;
            splitToken = strtok(NULL, "-");
          }

          // Check if the smallest number is first in the array, swap if not. Also done without a temporary variable!
          if (portBounds[0] > portBounds[1]) {
            portBounds[0] = portBounds[0] + portBounds[1];
            portBounds[1] = portBounds[0] - portBounds[1];
            portBounds[0] = portBounds[0] - portBounds[1];
          }

          tempIncrementor = 0;
          for(int i = portBounds[0]; i <= portBounds[1]; i++) {
            ports[tempIncrementor] = i;
            tempIncrementor++;
          }

          skipThisIteration = true;
          
        // top1000 ports. This does nothing, since the top 1000 ports are in the port array by default
        } else if (strcmp(argv[i + 1], "top1000") == 0) {
          skipThisIteration = true;

        // Some regex to check corect format of a comma seperated list
        } else if (match("^([1-9][0-9]{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])(,([1-9][0-9]{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5]))*$", argv[i + 1]) == 0) {
          
          // Clear current ports list
          for (int i = 0; i <= 65535; i++) {
            ports[i] = 0;
          }

          // More sanitization, this is equally as ugly :(
          strcpy(currentArgVPorts, argv[i + 1]);
          splitToken = strtok(currentArgVPorts, ",");
          tempIncrementor = 0;
          while (splitToken != NULL) {
            ports[tempIncrementor] = atoi(splitToken);
            tempIncrementor++;
            splitToken = strtok(NULL, ",");
          }

          skipThisIteration = true;
        } else {
          printHelp(argv[0]);
          return 1;
        }
      } else {
        strcpy(currentArgVIP, argv[i]);
        if (validateIP(currentArgVIP)) {
          argvHostIndex[argvHostIndexIterator] = i;
          argvHostIndexIterator++;
        } else {
          printf("unhandleded arg: %s\n", argv[i]);
          return 1;
        }
      }
    }
  }

  // Check if any hosts were actually specified
  if ((sizeof(argvHostIndex) / sizeof(argvHostIndex[0])) == 0) {
    printHelp(argv[0]);
    return 1;
  }

  // Now the magic beings
  // Iterate through the host lists
  for(int i = 0; i < argvHostIndexIterator; i++) {
    // Iterate through ports list, make sure it isnt zero (since the rest of the array is probably zeroed, unless all ports are selected)
    for(int j = 0; j <= 65535; j++) {
      if(ports[j] != 0) {

        // Check if isUp() returns 0, which means port is open
        if(isUp(argv[argvHostIndex[i]], ports[j], timeout) == 0) {
          printf("%s:%i (%s) is up\n", argv[argvHostIndex[i]], ports[j], getServiceByPort(ports[j]));
        }
      }
    }
  }

  // Memory management
  free(currentArgVIP);
  free(currentArgVPorts);
  free(currentArgVPortRange);
  return 0;
}
